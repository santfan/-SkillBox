##### **Создание репозитория**
Получить репозиторий можно двумя способами:
1. Можно взять локальный каталог, который не находится под версионном контролем и превратить его в репозиторий
2. Можно взять уже созданный ранее репозиторий и склонировать его на локальную систему

###### **Создание репозитория в усуществующем катологе**
Прежде всего необходимо перейти в каталого который не находится под версионным контролем командами
``` Linux
$ cd /home/user_name/directory_for_git
```
``` Windows
cd Диск/Директория_репозитория/
```
Дальше необходимо выполнить команду 
```
git init
```
для инициаци git . После этого добавить файлы, которые планируем поставить на версионный контроль командой
```
git add 'Имя файла'
```
команда 
```
git status
```
покажет что в 'On branch main' лежат проиндексированные файлы, которые ожидают подтверждения  (commit) Сделаем это комнадной
```
git commit -m 'On branch main'
```
После того как прошел commit необходимо положить файлы в github командой
```
git push git@github.com:имя_пользователя/имя_репозитория.git
```

###### **Клонирование уже существующего репозитория**
Для того чтобы клонировать репозиторий необходимо подать команду 
```
git clone git@github.com:Имя_пользователя/Имя_клонируемого репозитория
```
По этой команде будет создан клон репозитория

##### **Запись в репозиторий**




Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.

Как только будут внесены какие либо изменения в файл , этот файл сичтается измененным (модифицируемым). Модифицированные файлы необходимо commit . и потом положить на сервер. Далее цикл повторяется

![[Pasted image 20220802120227.png]]
Цикл жизни файла в репозитории.

###### **Определение состояния файла**
Основная команда определения в каком стотоянии находится файлы в ветке репозитория это команда
```
git status
```
Если не было никаких изменений файлов то должно высветится
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
Если же предположим был создан к примеру файл README, то 
```console
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
```
в этом сообщении говорится о том , что был создан файл README в ветке (в данном случае) master. Этот файл пока еще не индексирован и не добавлен в commit
Статус `Untracked` означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока явно об этом не попросить.

###### **Отслеживание новых файлов**
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add`. Чтобы начать отслеживание файла `README`, вы можете выполнить следующее:

```console
$ git add README
```

Если вы снова выполните команду `status`, то увидите, что файл `README` теперь отслеживаемый и добавлен в индекс:

```console
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README
```

Вы можете видеть, что файл проиндексирован, так как он находится в секции «Changes to be committed». Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды `git add`, будет добавлена в историю снимков состояния. Как вы помните, когда вы ранее выполнили `git init`, затем вы выполнили `git add (файлы)` — это было сделано для того, чтобы добавить файлы в вашем каталоге под версионный контроль. Команда `git add` принимает параметром путь к файлу или каталогу, если это каталог, команда `рекурсивно` добавляет все файлы из указанного каталога в индекс.

###### **Изменение индексированных файлов**
Если изменить отслеживаемый файл `CONTRIBUTING.md` и после этого снова выполнить команду `git status`, то результат будет следующим:

```console
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

Файл `CONTRIBUTING.md` находится в секции «Changes not staged for commit» — это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду `git add`. Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния. Выполним `git add`, чтобы проиндексировать `CONTRIBUTING.md`, а затем снова выполним `git status`:

```console
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
```

Теперь оба файла проиндексированы и войдут в следующий коммит. Теперь если внести изменение в уже проиндексированный файл и  ещё раз выполнить `git status`:

```console
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

То файл `CONTRIBUTING.md` отобразитстся как проиндексированный и непроиндексированный одновременно.  Git индексирует файл в точности в том состоянии, в котором он находился, когда вы выполнили команду `git add`. Если выполнить коммит сейчас, то файл `CONTRIBUTING.md` попадёт в коммит в том состоянии, в котором он находился, когда последний раз выполялась команда `git add` , а не в том, в котором он находится в момент выполнения `git commit`. Если вы изменить файл после выполнения `git add`, то необходимо снова выполнить `git add`, чтобы проиндексировать последнюю версию файла:

```console
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
```

###### **Сокращенный вывод команды status**
Git имеет флаг вывода сокращенного статуса. Если выполнить `git status -s` или `git status --short` , то получим упрощенный вывод:

```console
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```

Новые неотслеживаемые файлы помечены `??` слева от них, файлы добавленные в отслеживаемые помечены `A`, отредактированные файлы помечены `M` и так далее. В выводе содержится два столбца — в левом указывается статус файла, а в правом модифицирован ли он после этого. К примеру в нашем выводе, файл `README` модифицирован в рабочем каталоге, но не проиндексирован, а файл `lib/simplegit.rb` модифицирован и проиндексирован. Файл `Rakefile` модифицирован, проиндексирован и ещё раз модифицирован, таким образом на данный момент у него есть те изменения, которые попадут в коммит, и те, которые не попадут.

###### **Игнорирование файлов**
Если имеется группа файлов, которые не только не надо автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, надо  файл `.gitignore`. с перечислением шаблонов соответствующих таким файлам. Вот пример файла `.gitignore`:

```console
$ cat .gitignore
*.[oa]
*~
```

Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на «.o» или «.a» . Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду (`~`), которая используется во многих текстовых редакторах для обозначения временных файлов. Можно также включить каталоги log, tmp или pid; автоматически создаваемую документацию; и т. д. и т. п. Настраивать файл `.gitignore`  необходимо до начала работы с репозиторием, это позволит избежать случайного добавления в репозиторий файлов, которых вы там видеть не хотите.

К шаблонам в файле `.gitignore` применяются следующие правила:

-   Пустые строки, а также строки, начинающиеся с `#`, игнорируются.
    
-   Стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.
    
-   Чтобы избежать рекурсии используйте символ слеш (/) в начале шаблона.
    
-   Чтобы исключить каталог добавьте слеш (/) в конец шаблона.
    
-   Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.
    

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (`*`) соответствует 0 или более символам; последовательность `[abc]` — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (`?`) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом (`[0-9]`), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные каталоги: `a/**/z` соответствует `a/z`, `a/b/z`, `a/b/c/z`, и так далее.

Вот пример файла `.gitignore`:

```
# Исключить все файлы с расширением .a
*.a

# Но отслеживать файл lib.a даже если он подпадает под исключение выше
!lib.a

# Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO
/TODO

# Игнорировать все файлы в каталоге build/
build/

# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt
doc/*.txt

# Игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt
```



