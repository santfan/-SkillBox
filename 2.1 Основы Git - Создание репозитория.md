##### **Создание репозитория**
Получить репозиторий можно двумя способами:
1. Можно взять локальный каталог, который не находится под версионном контролем и превратить его в репозиторий
2. Можно взять уже созданный ранее репозиторий и склонировать его на локальную систему

###### **Создание репозитория в усуществующем катологе**
Прежде всего необходимо перейти в каталого который не находится под версионным контролем командами
``` Linux
$ cd /home/user_name/directory_for_git
```
``` Windows
cd Диск/Директория_репозитория/
```
Дальше необходимо выполнить команду 
```
git init
```
для инициаци git . После этого добавить файлы, которые планируем поставить на версионный контроль командой
```
git add 'Имя файла'
```
команда 
```
git status
```
покажет что в 'On branch main' лежат проиндексированные файлы, которые ожидают подтверждения  (commit) Сделаем это комнадной
```
git commit -m 'On branch main'
```
После того как прошел commit необходимо положить файлы в github командой
```
git push git@github.com:имя_пользователя/имя_репозитория.git
```

###### **Клонирование уже существующего репозитория**
Для того чтобы клонировать репозиторий необходимо подать команду 
```
git clone git@github.com:Имя_пользователя/Имя_клонируемого репозитория
```
По этой команде будет создан клон репозитория

##### **Запись в репозиторий**




Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.

Как только будут внесены какие либо изменения в файл , этот файл сичтается измененным (модифицируемым). Модифицированные файлы необходимо commit . и потом положить на сервер. Далее цикл повторяется

![[Pasted image 20220802120227.png]]
Цикл жизни файла в репозитории.

###### **Определение состояния файла**
Основная команда определения в каком стотоянии находится файлы в ветке репозитория это команда
```
git status
```
Если не было никаких изменений файлов то должно высветится
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
Если же предположим был создан к примеру файл README, то 
```console
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
```
в этом сообщении говорится о том , что был создан файл README в ветке (в данном случае) master. Этот файл пока еще не индексирован и не добавлен в commit
Статус `Untracked` означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока явно об этом не попросить.

###### **Отслеживание новых файлов**
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add`. Чтобы начать отслеживание файла `README`, вы можете выполнить следующее:

```console
$ git add README
```

Если вы снова выполните команду `status`, то увидите, что файл `README` теперь отслеживаемый и добавлен в индекс:

```console
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README
```

Вы можете видеть, что файл проиндексирован, так как он находится в секции «Changes to be committed». Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды `git add`, будет добавлена в историю снимков состояния. Как вы помните, когда вы ранее выполнили `git init`, затем вы выполнили `git add (файлы)` — это было сделано для того, чтобы добавить файлы в вашем каталоге под версионный контроль. Команда `git add` принимает параметром путь к файлу или каталогу, если это каталог, команда `рекурсивно` добавляет все файлы из указанного каталога в индекс.

###### **Изменение индексированных файлов**
Если изменить отслеживаемый файл `CONTRIBUTING.md` и после этого снова выполнить команду `git status`, то результат будет следующим:

```console
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

Файл `CONTRIBUTING.md` находится в секции «Changes not staged for commit» — это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду `git add`. Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния. Выполним `git add`, чтобы проиндексировать `CONTRIBUTING.md`, а затем снова выполним `git status`:

```console
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
```

Теперь оба файла проиндексированы и войдут в следующий коммит. Теперь если внести изменение в уже проиндексированный файл и  ещё раз выполнить `git status`:

```console
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

То файл `CONTRIBUTING.md` отобразитстся как проиндексированный и непроиндексированный одновременно.  Git индексирует файл в точности в том состоянии, в котором он находился, когда вы выполнили команду `git add`. Если выполнить коммит сейчас, то файл `CONTRIBUTING.md` попадёт в коммит в том состоянии, в котором он находился, когда последний раз выполялась команда `git add` , а не в том, в котором он находится в момент выполнения `git commit`. Если вы изменить файл после выполнения `git add`, то необходимо снова выполнить `git add`, чтобы проиндексировать последнюю версию файла:

```console
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
```

###### **Сокращенный вывод команды status**
Git имеет флаг вывода сокращенного статуса. Если выполнить `git status -s` или `git status --short` , то получим упрощенный вывод:

```console
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```

Новые неотслеживаемые файлы помечены `??` слева от них, файлы добавленные в отслеживаемые помечены `A`, отредактированные файлы помечены `M` и так далее. В выводе содержится два столбца — в левом указывается статус файла, а в правом модифицирован ли он после этого. К примеру в нашем выводе, файл `README` модифицирован в рабочем каталоге, но не проиндексирован, а файл `lib/simplegit.rb` модифицирован и проиндексирован. Файл `Rakefile` модифицирован, проиндексирован и ещё раз модифицирован, таким образом на данный момент у него есть те изменения, которые попадут в коммит, и те, которые не попадут.

###### **Игнорирование файлов**
Если имеется группа файлов, которые не только не надо автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, надо  файл `.gitignore`. с перечислением шаблонов соответствующих таким файлам. Вот пример файла `.gitignore`:

```console
$ cat .gitignore
*.[oa]
*~
```

Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на «.o» или «.a» . Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду (`~`), которая используется во многих текстовых редакторах для обозначения временных файлов. Можно также включить каталоги log, tmp или pid; автоматически создаваемую документацию; и т. д. и т. п. Настраивать файл `.gitignore`  необходимо до начала работы с репозиторием, это позволит избежать случайного добавления в репозиторий файлов, которых вы там видеть не хотите.

К шаблонам в файле `.gitignore` применяются следующие правила:

-   Пустые строки, а также строки, начинающиеся с `#`, игнорируются.
    
-   Стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.
    
-   Чтобы избежать рекурсии используйте символ слеш (/) в начале шаблона.
    
-   Чтобы исключить каталог добавьте слеш (/) в конец шаблона.
    
-   Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.
    

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (`*`) соответствует 0 или более символам; последовательность `[abc]` — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (`?`) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом (`[0-9]`), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные каталоги: `a/**/z` соответствует `a/z`, `a/b/z`, `a/b/c/z`, и так далее.

Вот пример файла `.gitignore`:

```
# Исключить все файлы с расширением .a
*.a

# Но отслеживать файл lib.a даже если он подпадает под исключение выше
!lib.a

# Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO
/TODO

# Игнорировать все файлы в каталоге build/
build/

# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt
doc/*.txt

# Игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt
```

###### **Просмотр проиндексированных и не проиндексированных файлов**
Если надо знать, что конкретно поменялось, а не только какие файлы были изменены —  можно использовать команду `git diff`. Команда  `git diff` показывает что изменилось, но ещё не проиндексировано, и что проиндексировано но пока не скоммитчено непосредственно добавленные и удалённые строки — патч как он есть.

Допустим, был изменен и проиндексирован файл `README`, а затем изменен файл `CONTRIBUTING.md` без индексирования. Если выполнить команду `git status`, то выведется:

```console
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

Чтобы увидеть, что же изменилось, но пока не проиндексировано, наберем `git diff` без аргументов:

```console
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
```

Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.

Если надо посмотреть, что проиндексировано и что войдёт в следующий коммит, нода выполнить `git diff --staged`. Эта команда сравнивает проиндексированные изменения с последним коммитом:

```console
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
```

Важно отметить, что `git diff` сама по себе не показывает все изменения сделанные с последнего коммита — только те, что ещё не проиндексированы. Такое поведение может сбивать с толку, так как если вы проиндексируете все свои изменения, то `git diff` ничего не вернёт.

Другой пример: вы проиндексировали файл `CONTRIBUTING.md` и затем изменили его, вы можете использовать `git diff` для просмотра как проиндексированных изменений в этом файле, так и тех, что пока не проиндексированы. Если наше окружение выглядит вот так:

```console
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

Используйте `git diff` для просмотра непроиндексированных изменений

```console
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
```

а так же `git diff --cached` для просмотра проиндексированных изменений (`--staged` и `--cached` синонимы):

```console
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
```

##### **Коммит  изменений**
Теперь можно зафиксировать изменения. Уточним что, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили `git add` после редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске. Когда в последний раз выполялось `git status`, можно видеть всё проиндексировано теперь все готово к коммиту. Простейший способ зафиксировать изменения — это набрать `git commit`:

```console
$ git commit
```

Эта команда откроет выбранный вами текстовый редактор.
В редакторе будет отображён следующий текст (это пример окна Vim):

```
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
```

Вы можете видеть, что комментарий по умолчанию для коммита содержит закомментированный результат работы команды `git status` и ещё одну пустую строку сверху. Вы можете удалить эти комментарии и набрать своё сообщение или же оставить их для напоминания о том, что вы фиксируете.

Для ещё более подробного напоминания, что же именно вы поменялось, можно передать аргумент `-v` в команду `git commit`. Это приведёт к тому, что в комментарий будет также помещена дельта/diff изменений, таким образом можно точно увидеть все изменения 

Когда вы выходите из редактора, Git создаёт для вас коммит с этим сообщением, удаляя комментарии и вывод команды `diff`.

Есть и другой способ — можно набрать свой комментарий к коммиту в командной строке вместе с командой `commit` указав его после параметра `-m`, как в следующем примере:

```console
$ git commit -m "Story 182: fix benchmarks for speed"
[master 463dc4f] Story 182: fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
```

Коммит вывел информацию : на какую ветку выполнен коммит (`master`), какая контрольная сумма SHA-1 у этого коммита (`463dc4f`), сколько файлов было изменено, а также статистику по добавленным/удалённым строкам в этом коммите.

Итак коммит сохраняет снимок состояния индекса. Всё, что не проиндексировано, так и висит в рабочем каталоге как изменённое; необходимо сделать ещё один коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда делается коммит, сохраняется снимок состояния проекта, который позже можно восстановить или с которым можно сравнить текущее состояние.

###### **Игнорирование индексации**
Можно пропустить этап индексирования - добавление параметра `-a` в команду `git commit` заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без `git add`:

```console
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'Add new benchmarks'
[master 83e38c7] Add new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
```

Обратите внимание, что в данном случае перед коммитом вам не нужно выполнять `git add` для файла `CONTRIBUTING.md`, потому что флаг `-a` включает все файлы. Это удобно, но  флаг `-a` может включить в коммит нежелательные изменения.

###### **Удаление файлов**
Для того чтобы удалить файл из Git, необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда `git rm`, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».

Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции «Changes not staged for commit» (измененные, но не проиндексированные) вывода команды `git status`:

```console
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
```

Затем, если вы выполните команду `git rm`, удаление файла попадёт в индекс:

```console
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
```

После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра `-f`. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.

Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на жёстком диске, но перестать отслеживать изменения в нём. Это особенно полезно, если вы забыли добавить что-то в файл `.gitignore` и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию `--cached`:

```console
$ git rm --cached README
```

В команду `git rm` можно передавать файлы, каталоги или шаблоны. Это означает, что вы можете сделать что-то вроде:

```console
$ git rm log/\*.log
```

Обратите внимание на обратный слеш (`\`) перед `*`. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы, имеющие расширение `.log` и находящиеся в каталоге `log/`. Или же вы можете сделать вот так:

```console
$ git rm \*~
```

Эта команда удаляет все файлы, имена которых заканчиваются на `~`.

###### **Перемещение файлов**
В отличие от многих других систем контроля версий, Git не отслеживает перемещение файлов явно. Когда вы переименовываете файл в Git, в нём не сохраняется никаких метаданных, говорящих о том, что файл был переименован.  Если надо переименовать файл в Git, можно сделать :

```console
$ git mv file_from file_to
```

 На самом деле, если  выполнить эту команду и посмотрите на статус, можно увидеть, что Git считает, что произошло переименование файла:

```console
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
```

Однако, это эквивалентно выполнению следующих команд:

```console
$ mv README.md README
$ git rm README.md
$ git add README
```

Git неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду `mv`. Единственное отличие состоит лишь в том, что `mv` — одна команда вместо трёх — это функция для удобства. Важнее другое — вы можете использовать любой удобный способ для переименования файла, а затем воспользоваться командами `add` или `rm` перед коммитом.